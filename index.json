[{"content":"\u0026lt;문제 바로가기\u0026gt; 풀이 접근 포인트    1개의 상태에서 4개(상하좌우)의 상태로 확장 가능하다.\n 모든 상태의 수 : 45 각 상태의 마지막 단계에서 최대 블록을 만들 수 있다고 가정한다. DFS를 이용하여 모든 상태를 방문한다.    상-하 , 좌-우는 서로 정반대의 동작이기 때문에 구현도 정반대로 이루어진다.\n   소스코드 보기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; int solve(int cnt , int Map[][20]); int N; int Map[20][20]; int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr); int i,j,ret; cin \u0026gt;\u0026gt; N; for(i=0; i\u0026lt;N; i++) for(j=0; j\u0026lt;N; j++) cin \u0026gt;\u0026gt; Map[i][j]; cout \u0026lt;\u0026lt; solve(0,Map) \u0026lt;\u0026lt; endl; } int solve(int cnt , int Map[][20]) { int i,j,k,dir,val,ret=0; int Array[20][20] = {0,}; if(cnt == 5) { for(i=0; i\u0026lt;N; i++) for(j=0; j\u0026lt;N; j++) ret = max(ret , Map[i][j]); return ret; } for(dir=0; dir\u0026lt;4; dir++) { for(i=0; i\u0026lt;N; i++) { vector\u0026lt;int\u0026gt; line; for(j=0; j\u0026lt;N; j++) { val = (dir\u0026lt;2 ? Map[i][j] : Map[j][i]); if(val != 0)\tline.push_back(val); } if(dir == 1 || dir == 3) reverse(line.begin(),line.end()); vector\u0026lt;int\u0026gt; mix_line; for(k=0; k\u0026lt;line.size(); k++) { if(k+1 \u0026lt; line.size() \u0026amp;\u0026amp; line[k+1] == line[k]) { mix_line.push_back(line[k]*2); k++; } else mix_line.push_back(line[k]); } for(k=mix_line.size(); k\u0026lt;N; k++) mix_line.push_back(0); if(dir == 1 || dir == 3) reverse(mix_line.begin(),mix_line.end()); for(j=0; j\u0026lt;N; j++) (dir\u0026lt;2 ? Array[i][j] : Array[j][i]) = mix_line[j]; } ret = max(ret , solve(cnt+1 , Array)); } return ret; }   ","description":"백준 12100번 풀이","id":0,"section":"posts","tags":["BOJ"],"title":"[BOJ 12100] 2048(Easy)","uri":"http://xcv3549.github.io/posts/markdown-syntax/"}]