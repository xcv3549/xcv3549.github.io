[{"content":"\u0026lt;문제 바로가기\u0026gt; 풀이  구현 포인트  주사위의 방향별로 각 주사위 면이 바뀌는 코드를 구현해준다.   소스코드 보기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103  #include \u0026lt;iostream\u0026gt; using namespace std; int Map[21][21]; int Move_Dir[1000]; int dice[7]; int dx[4] = {1,-1,0,0}; int dy[4] = {0,0,-1,1}; int N,M,K; void solve(int x , int y); bool IsSafe(int x , int y); int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int x,y,i,j; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M \u0026gt;\u0026gt; y \u0026gt;\u0026gt; x \u0026gt;\u0026gt; K; for(i=0; i\u0026lt;N; i++) for(j=0; j\u0026lt;M; j++) cin \u0026gt;\u0026gt; Map[i][j]; for(i=0; i\u0026lt;K; i++) cin \u0026gt;\u0026gt; Move_Dir[i]; solve(x,y); } void solve(int x , int y) { int i,dir,nx,ny,top; for(i=0; i\u0026lt;K; i++) { dir = Move_Dir[i]; nx = x + dx[dir-1]; ny = y +dy[dir-1]; if(!IsSafe(nx,ny))\tcontinue; x = nx; y = ny; top = dice[1]; if(dir == 1) { dice[1] = dice[4]; dice[4] = dice[6]; dice[6] = dice[3]; dice[3] = top; } else if(dir == 2) { dice[1] = dice[3]; dice[3] = dice[6]; dice[6] = dice[4]; dice[4] = top; } else if(dir == 3) { dice[1] = dice[5]; dice[5] = dice[6]; dice[6] = dice[2]; dice[2] = top; } else { dice[1] = dice[2]; dice[2] = dice[6]; dice[6] = dice[5]; dice[5] = top; } if(Map[y][x] == 0)\tMap[y][x] = dice[6]; else { dice[6] = Map[y][x]; Map[y][x] = 0; } cout \u0026lt;\u0026lt; dice[1] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } bool IsSafe(int x , int y) { return x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; M \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; N; }   ","description":"백준 14499번 풀이","id":0,"section":"posts","tags":["BOJ"],"title":"[BOJ 14499] 주사위 굴리기","uri":"http://xcv3549.github.io/posts/14499/"},{"content":"\u0026lt;문제 바로가기\u0026gt; 풀이  구현 포인트  주사위의 방향별로 각 주사위 면이 바뀌는 코드를 구현해준다.   소스코드 보기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103  #include \u0026lt;iostream\u0026gt; using namespace std; int Map[21][21]; int Move_Dir[1000]; int dice[7]; int dx[4] = {1,-1,0,0}; int dy[4] = {0,0,-1,1}; int N,M,K; void solve(int x , int y); bool IsSafe(int x , int y); int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int x,y,i,j; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M \u0026gt;\u0026gt; y \u0026gt;\u0026gt; x \u0026gt;\u0026gt; K; for(i=0; i\u0026lt;N; i++) for(j=0; j\u0026lt;M; j++) cin \u0026gt;\u0026gt; Map[i][j]; for(i=0; i\u0026lt;K; i++) cin \u0026gt;\u0026gt; Move_Dir[i]; solve(x,y); } void solve(int x , int y) { int i,dir,nx,ny,top; for(i=0; i\u0026lt;K; i++) { dir = Move_Dir[i]; nx = x + dx[dir-1]; ny = y +dy[dir-1]; if(!IsSafe(nx,ny))\tcontinue; x = nx; y = ny; top = dice[1]; if(dir == 1) { dice[1] = dice[4]; dice[4] = dice[6]; dice[6] = dice[3]; dice[3] = top; } else if(dir == 2) { dice[1] = dice[3]; dice[3] = dice[6]; dice[6] = dice[4]; dice[4] = top; } else if(dir == 3) { dice[1] = dice[5]; dice[5] = dice[6]; dice[6] = dice[2]; dice[2] = top; } else { dice[1] = dice[2]; dice[2] = dice[6]; dice[6] = dice[5]; dice[5] = top; } if(Map[y][x] == 0)\tMap[y][x] = dice[6]; else { dice[6] = Map[y][x]; Map[y][x] = 0; } cout \u0026lt;\u0026lt; dice[1] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } bool IsSafe(int x , int y) { return x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; M \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; N; }   ","description":"백준 14499번 풀이","id":1,"section":"posts","tags":["BOJ"],"title":"[BOJ 14499] 주사위 굴리기","uri":"http://xcv3549.github.io/posts/14499_copy0/"},{"content":"\u0026lt;문제 바로가기\u0026gt; 풀이 접근 포인트   각 시험장의 응시자들을 모두 감시해야 한다 =\u0026gt; 응시자 수에 맞게 감독관을 배치해야 한다. 1개의 시험장에는 총감독관이 1명 있어야 한다. (0명 X , 1명 초과 X) 부감독관(들)이 감시해야 할 응시자 = 시험장의 응시자 - 총감독관이 감시할 수 있는 응시자   구현 포인트   각 시험장마다 총감독관은 1명씩 있어야하기 때문에, 감독관의 최소 수는 N(시험장 수) 이상이다.  ans(감독관 최소 수) += N(시험장 수)   접근 포인트 3번식을 바탕으로 구현한다.  소스코드 보기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  #include \u0026lt;iostream\u0026gt; using namespace std; int P[1000001]; int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr); int N,B,C,i,p_num; int64_t ans=0; cin \u0026gt;\u0026gt; N; for(i=0; i\u0026lt;N; i++) cin \u0026gt;\u0026gt; P[i]; cin \u0026gt;\u0026gt; B \u0026gt;\u0026gt; C; ans += N; for(i=0; i\u0026lt;N; i++) { p_num = P[i] - B; if(p_num \u0026gt; 0) { if(p_num % C \u0026gt; 0) ans += p_num/C + 1; else ans += p_num/C; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }   ","description":"백준 13458번 풀이","id":2,"section":"posts","tags":["BOJ"],"title":"[BOJ 13458] 시험 감독","uri":"http://xcv3549.github.io/posts/13458/"},{"content":"\u0026lt;문제 바로가기\u0026gt; 풀이 접근 포인트  시뮬레이션 문제. NxN 보드의 상태는 3가지이다.  빈 공간 , 사과 , 뱀   NxN 보드의 각 상태 변화는 뱀의 이동으로 인해 이루어진다.  뱀의 이동은 방향의 영향을 받는다. 방향은 X(시간),C(방향변화) 변수의 영향을 받는다.     구현 포인트  NxN 보드의 상태는 아래 3가지와 같이 구현한다.  빈 공간(0) , 사과(1) , 뱀(2)   뱀은 Queue를 이용하여 구현한다.  Push : 머리 (뱀이 이동할 구역) Pop : 꼬리 (뱀의 마지막 부분)   사과의 유무  사과가 있을 경우 : Push 사과가 없을 경우 : Push , Pop   방향의 변화도 Queue를 이용하여 구현한다.  X와 sec가 일치할 경우, 뱀의 진행방향을 C(주어진 방향)으로 변경한다.     소스코드 보기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  #include \u0026lt;iostream\u0026gt;#include \u0026lt;queue\u0026gt; using namespace std; using PII = pair\u0026lt;int,int\u0026gt;; const int Apple = 1; const int Body = 2; const int Left = 3; const int Right = 1; const int dx[4] = {0,1,0,-1}; const int dy[4] = {-1,0,1,0}; int Map[100][100]; int N; queue\u0026lt;PII\u0026gt; Change_Dir; //L = left , D = Right  int solve(); bool IsSafe(int x,int y); int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr); int K,L,X,i,x,y,d; char C; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K; for(i=0; i\u0026lt;K; i++) { cin \u0026gt;\u0026gt; y \u0026gt;\u0026gt; x; Map[y-1][x-1] = Apple; } cin \u0026gt;\u0026gt; L; for(i=0; i\u0026lt;L; i++) { cin \u0026gt;\u0026gt; X \u0026gt;\u0026gt; C; d = (C == \u0026#39;L\u0026#39; ? Left : Right); Change_Dir.push({X,d}); } cout \u0026lt;\u0026lt; solve() \u0026lt;\u0026lt; endl; } int solve() { // initialize \tqueue\u0026lt;PII\u0026gt; Snake; int x = 0 , y = 0; int sec = 0 , dir = 1; int bx,by; Snake.push({0,0}); Map[0][0] = Body; while(true) { //Move \tx += dx[dir]; y += dy[dir]; Snake.push({x,y}); //Check Next Map \tif(!IsSafe(x,y) || Map[y][x] == Body) return sec + 1; else if(Map[y][x] == Apple) Map[y][x] = Body; else\t{ Map[y][x] = Body; bx = Snake.front().first; by = Snake.front().second; Snake.pop(); Map[by][bx] = 0; } sec++; //Check Direction \tif(Change_Dir.front().first == sec) { dir = (dir + Change_Dir.front().second) % 4; Change_Dir.pop(); } } } bool IsSafe(int x,int y) { return x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; N \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; N; }   ","description":"백준 3190번 풀이","id":3,"section":"posts","tags":["BOJ"],"title":"[BOJ 3190] 뱀","uri":"http://xcv3549.github.io/posts/3190/"},{"content":"\u0026lt;문제 바로가기\u0026gt; 풀이 접근 포인트    1개의 상태에서 4개(상하좌우)의 상태로 확장 가능하다.\n 모든 상태의 수 : 45 각 상태의 마지막 단계에서 최대 블록을 만들 수 있다고 가정한다. DFS를 이용하여 모든 상태를 방문한다.    상-하 , 좌-우는 서로 정반대의 동작이기 때문에 구현도 정반대로 이루어진다.\n   소스코드 보기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; int solve(int cnt , int Map[][20]); int N; int Map[20][20]; int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr); int i,j,ret; cin \u0026gt;\u0026gt; N; for(i=0; i\u0026lt;N; i++) for(j=0; j\u0026lt;N; j++) cin \u0026gt;\u0026gt; Map[i][j]; cout \u0026lt;\u0026lt; solve(0,Map) \u0026lt;\u0026lt; endl; } int solve(int cnt , int Map[][20]) { int i,j,k,dir,val,ret=0; int Array[20][20] = {0,}; if(cnt == 5) { for(i=0; i\u0026lt;N; i++) for(j=0; j\u0026lt;N; j++) ret = max(ret , Map[i][j]); return ret; } for(dir=0; dir\u0026lt;4; dir++) { for(i=0; i\u0026lt;N; i++) { vector\u0026lt;int\u0026gt; line; for(j=0; j\u0026lt;N; j++) { val = (dir\u0026lt;2 ? Map[i][j] : Map[j][i]); if(val != 0)\tline.push_back(val); } if(dir == 1 || dir == 3) reverse(line.begin(),line.end()); vector\u0026lt;int\u0026gt; mix_line; for(k=0; k\u0026lt;line.size(); k++) { if(k+1 \u0026lt; line.size() \u0026amp;\u0026amp; line[k+1] == line[k]) { mix_line.push_back(line[k]*2); k++; } else mix_line.push_back(line[k]); } for(k=mix_line.size(); k\u0026lt;N; k++) mix_line.push_back(0); if(dir == 1 || dir == 3) reverse(mix_line.begin(),mix_line.end()); for(j=0; j\u0026lt;N; j++) (dir\u0026lt;2 ? Array[i][j] : Array[j][i]) = mix_line[j]; } ret = max(ret , solve(cnt+1 , Array)); } return ret; }   ","description":"백준 12100번 풀이","id":4,"section":"posts","tags":["BOJ"],"title":"[BOJ 12100] 2048(Easy)","uri":"http://xcv3549.github.io/posts/12100/"}]